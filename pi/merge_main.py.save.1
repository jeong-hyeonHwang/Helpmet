import asyncio
import json
import cv2
import traceback
import numpy as np
import time
from av import VideoFrame
from aiohttp import web
from aiortc import RTCPeerConnection, RTCSessionDescription, VideoStreamTrack
import base64
import os
from arrow import arrow_loop, turn_on_arrow, turn_off_arrow
from contextlib import asynccontextmanager

# WebSocket 클라이언트 저장소
websockets = set()

# WebRTC 연결 저장소
pcs = set()

camera_in_use = asyncio.Lock()

is_speaking = False

# 프레임 브로드캐스트 함수
async def broadcast_frame_to_websockets(frame, websockets):
    if not websockets:
        return

    try:
        encode_param = [int(cv2.IMWRITE_JPEG_QUALITY), 70]
        _, buffer = cv2.imencode('.jpg', frame, encode_param)
        jpg_as_text = base64.b64encode(buffer).decode('utf-8')

        message = {
            "type": "frame",
            "data": jpg_as_text,
            "timestamp": round(time.time() * 1000)
        }

        data = json.dumps(message)
        await asyncio.gather(*[ws.send_str(data) for ws in websockets])

    except Exception as e:
        print(f"[오류] 프레임 전송 중 오류 발생: {str(e)}")

async def broadcast_playing_to_websockets(state, ws):
    if not websockets:
        return
    
    try:
        message = {
            "type": "speaking",
            "is_speaking": state
        }

        data = json.dumps(message)
        await ws.send_str(data)

    except Exception as e:
        print(f"[오류] Speaking Lock 전송 중 오류 발생: {str(e)}")


# 비동기 음성 안내 함수
async def play_audio_async(filepath, ws):
    global is_speaking
    if is_speaking:
        print(f"[음성] 이미 재생 중: {filepath} 무시됨")
        return
    is_speaking = True
    
    try:
        await broadcast_playing_to_websockets(is_speaking, ws)
        print(f"[음성] 재생 시작: {filepath}")
        process = await asyncio.create_subprocess_exec("mpg123", "-a", "plughw:1,0", filepath)
        await process.wait()
    finally:
        is_speaking = False
        await broadcast_playing_to_websockets(is_speaking, ws)
        print(f"[음성] 재생 완료: {filepath}")

        
# 카메라 트랙 클래스
class CameraStreamTrack(VideoStreamTrack):
    def __init__(self):
        super().__init__()
        self.frame_id = 0
        self.fps_counter = 0
        self.fps_timer = time.time()
        self.fps = 0

        retries = 5
        for i in range(retries):
            self.cap = cv2.VideoCapture(
                "v4l2src device=/dev/video0 ! video/x-raw,width=640,height=480,framerate=15/1 ! "
                "videoconvert ! video/x-raw,format=BGR ! appsink",
                cv2.CAP_GSTREAMER
            )
            if self.cap.isOpened():
                break
            print(f"[카메라] 열기 실패! 재시도: {i+1}/{retries}")
            time.sleep(0.3)

        if not self.cap.isOpened():
            print("[카메라] GStreamer 실패. 일반 모드 시도.")
            self.cap = cv2.VideoCapture(0)
            if not self.cap.isOpened():
                raise RuntimeError("카메라를 열 수 없습니다.")

        print("[카메라] 초기화 완료")

    async def recv(self):
        pts, time_base = await self.next_timestamp()
        ret, frame = self.cap.read()
        if not ret:
            print("[카메라] 프레임 읽기 실패")
            try:
                self.stop()
            except Exception as e:
                print("[카메라] 종료 실패")
                print("[서버] 서버를 종료합니다")
                asyncio.run(cleanup({}))
            frame = np.zeros((480, 640, 3), dtype=np.uint8)

        self.frame_id += 1
        current_time = time.time()

        if self.frame_id % 6 == 1 and websockets:
            await broadcast_frame_to_websockets(frame, websockets)

        self.fps_counter += 1
        if current_time - self.fps_timer > 1.0:
            self.fps = self.fps_counter / (current_time - self.fps_timer)
            self.fps_counter = 0
            self.fps_timer = current_time

        video_frame = VideoFrame.from_ndarray(frame, format="bgr24")
        video_frame.pts = pts
        video_frame.time_base = time_base

        return video_frame

    async def stop(self):
        if self.cap and self.cap.isOpened():
            self.cap.release()
        await super().stop()

# 라우트 설정
routes = web.RouteTableDef()
speaker_module = None

@routes.get("/")
async def index(request):
    with open("templates/index.html", "r", encoding="utf-8") as f:
        content = f.read()
    return web.Response(text=content, content_type="text/html")

@routes.get("/ws")
async def websocket_handler(request):
    print("[WS] 연결 요청")
    ws = web.WebSocketResponse()
    await ws.prepare(request)

    websockets.add(ws)
    print(f"[WS] 연결됨 (총 {len(websockets)})")

    try:
        async for msg in ws:
            if msg.type == web.WSMsgType.TEXT:
                try:
                    data = json.loads(msg.data)
                    msg_type = data.get("type")

                    if msg_type == "turn_left":
                        if data.get("command") == "start":
                            turn_on_arrow(0)
                        elif data.get("command") == "stop":
                            turn_off_arrow(0)

                    elif msg_type == "turn_right":
                        if data.get("command") == "start":
                            turn_on_arrow(1)
                        elif data.get("command") == "stop":
                            turn_off_arrow(1)

                    elif msg_type == "turn_off":
                        cmd = data.get("command")
                        if cmd == "left" or cmd == "both":
                            turn_off_arrow(0)
                        if cmd == "right" or cmd == "both":
                            turn_off_arrow(1)

                    elif msg_type == "PERSON_DETECTED":
                        level = data.get("level")
                        if level == 1:
                            print("[주의] 사람 1단계 경고")
                            asyncio.create_task(play_audio_async("person_1.mp3", ws))
                        elif level == 2:
                            print("[위험] 사람 2단계 경고")
                            asyncio.create_task(play_audio_async("person_2.mp3", ws))

                    elif msg_type == "CAR_DETECTED":
                        level = data.get("level")
                        if level == 1:
                            print("[주의] 자동차 1단계 경고")
                            asyncio.create_task(play_audio_async("car_1.mp3", ws))
                        elif level == 2:
                            print("[위험] 자동차 2단계 경고")
                            asyncio.create_task(play_audio_async("car_2.mp3", ws))

                    elif msg_type == "BICYCLE_DETECTED":
                        level = data.get("level")
                        if level == 1:
                            print("[주의] 자전거 1단계 경고")
                            asyncio.create_task(play_audio_async("bicycle_1.mp3", ws))
                        elif level == 2:
                            print("[위험] 자전거 2단계 경고")
                            asyncio.create_task(play_audio_async("bicycle_2.mp3", ws))
                except Exception as e:
                    print(f"[WS] 메시지 처리 오류: {e}")
    finally:
        websockets.remove(ws)
        print(f"[WS] 연결 해제됨 (총 {len(websockets)})")

    return ws

@routes.post("/offer")
async def offer(request):
    params = await request.json()
    offer = RTCSessionDescription(sdp=params["sdp"], type=params["type"])

    pc = RTCPeerConnection()
    pcs.add(pc)

    await camera_in_use.acquire()
    print(f"[RTC] 연결 생성 (총 {len(pcs)})")

    try:
        video = CameraStreamTrack()
        pc.addTrack(video)
    except RuntimeError as e:
        print(f"[에러] 카메라 실패: {e}")
        await pc.close()
        pcs.discard(pc)
        camera_in_use.release()
        return web.Response(status=500, text="카메라 열기 실패")

    @pc.on("connectionstatechange")
    async def on_connectionstatechange():
        print(f"[RTC] 상태: {pc.connectionState}")
        if pc.connectionState in ["closed", "failed", "disconnected"]:
            await video.stop()
            await pc.close()
            pcs.discard(pc)
            camera_in_use.release()
            print("[RTC] 연결 종료 및 리소스 정리")
    print("[RTC] setRemoteDescription(offer) 실행 시작")
    await pc.setRemoteDescription(offer)
    print("[RTC] setRemoteDescription(offer) 실행 종료")
    answer = await pc.createAnswer()
    print("[RTC] setRemoteDescription(answer) 실행 시작")
    await pc.setLocalDescription(answer)
    print("[RTC] setRemoteDescription(answer) 실행 종료")

    return web.json_response({
        "sdp": pc.localDescription.sdp,
        "type": pc.localDescription.type
    })

@routes.post("/disconnect")
async def disconnect(request):
    print("[클라이언트] 연결 끊기 요청")
    for pc in list(pcs):
        await pc.close()
        pcs.discard(pc)
    for ws in list(websockets):
        websockets.discard(ws)
    return web.Response(text="Disconnected")

@routes.get("/info")
async def get_info(request):
  
isAccess = True

    if len(websockets) >= 1:
        isAccess = False

    return web.json_response({"serviceName": "HELPMET", "isAccess": isAccess})

async def start_arrow_loop(app):
    app['arrow_task'] = asyncio.create_task(arrow_loop())

async def cleanup(app):
    print("[메인] 리소스 정리 중...")

    arrow_task = app.get('arrow_task')
    if arrow_task:
        arrow_task.cancel()
        try:
            await arrow_task
        except asyncio.CancelledError:
            print("arrow_loop() 작업이 취소되었습니다.")

    tasks = [pc.close() for pc in pcs]
    if tasks:
        loop = asyncio.get_event_loop()
        loop.run_until_complete(asyncio.gather(*tasks))
    print("[메인] 리소스 정리 완료")

def create_app():
    app = web.Application()
    app.add_routes(routes)
    app.on_startup.append(start_arrow_loop)
    app.on_shutdown.append(cleanup)
    return app

if __name__ == "__main__":
    try:
        print("==== HELPMET 스트리밍 서버 시작 ====")
        web.run_app(create_app(), host="0.0.0.0", port=8081)
    except KeyboardInterrupt:
        print("종료 요청 수신됨")
    except Exception as e:
        print(f"서버 오류: {e}")
        traceback.print_exc()
    finally:
        asyncio.run(cleanup({}))
        print("서버가 종료되었습니다.")
